(include "qq.scm")
(include "memory_layout.scm")
(include "opcodes.scm")

(define (mask-byte b)
  (bitwise-and 255 b))

(define (write-u16 v p)
  (when (< 65536 (abs v)) (error "Invalid write-u16"))
  (write-u8 (mask-byte v) p)
  (write-u8 (mask-byte (arithmetic-shift v -8)) p))

(define (write-u32 v p)
  (write-u8 (mask-byte v) p)
  (write-u8 (mask-byte (arithmetic-shift v -8)) p)
  (write-u8 (mask-byte (arithmetic-shift v -16)) p)
  (write-u8 (mask-byte (arithmetic-shift v -24)) p))

(define (write-u64 v p)
  (write-u8 (mask-byte v) p)
  (write-u8 (mask-byte (arithmetic-shift v -8)) p)
  (write-u8 (mask-byte (arithmetic-shift v -16)) p)
  (write-u8 (mask-byte (arithmetic-shift v -24)) p)
  (write-u8 (mask-byte (arithmetic-shift v -32)) p)
  (write-u8 (mask-byte (arithmetic-shift v -40)) p)
  (write-u8 (mask-byte (arithmetic-shift v -48)) p)
  (write-u8 (mask-byte (arithmetic-shift v -56)) p))

(define-record-type fun (%make-fun code name const-list const bc-start) fun?
		    (code fun-code fun-code-set!)
		    (name fun-name fun-name-set!)
		    (const-list fun-const-list fun-const-list-set!)
		    (const fun-const fun-const-set!)
		    (bc-start fun-bc-start fun-bc-start-set!))

(define (make-fun name)
  (%make-fun '() name '() (make-hash-table equal?) 1))

(define (push-instr! fun instr)
  (fun-code-set! fun (cons instr (fun-code fun))))

(define functions '())
(define (add-constant fun c)
  (cond
   ((hash-table-ref/default (fun-const fun) c #f))
   (else
    (let ((id (hash-table-size (fun-const fun))))
      (hash-table-set! (fun-const fun)  c id)
      (fun-const-list-set! fun (cons c (fun-const-list fun)))
      id))))

(define-record-type loop-var (make-loop-var dest rg) loop-var?
		    (dest loop-var-dest)
		    (rg loop-var-rg))

(define (check-need-arg res reg)
  (eqv? res reg))

(define quick-branches '(LT GT LTE GTE NUM_EQ EQ GUARD))

(define (emit sexp env fun rg tail)
  (define (finish res)
    (if tail
	(begin
	  (when res (push-instr! fun `(RET 0 ,res)))
	  #f)
	res))
  (match sexp
    ((begin ,sexps ___ ,end)
     (for sexp sexps
	  (emit sexp env fun rg #f))
     (emit end env fun rg tail))
    ((set! ,var ,val)
     (define reg (emit val env fun rg #f))
     (unless (check-need-arg reg rg)
       (push-instr! fun (list 'ARG rg reg)))
     (push-instr! fun `(DEFINE ,rg ,(add-constant fun var)))
     (finish rg))
    ((define ,var ,val)
     (define reg (emit val env fun rg #f))
     (unless (check-need-arg reg rg)
       (push-instr! fun (list 'ARG rg reg)))
     (push-instr! fun `(DEFINE ,rg ,(add-constant fun var)))
     (finish rg))
    ((primcall closure-ref ,var ,cnt)
     (push-instr! fun (list 'CLOSURE-REF rg (emit var env fun rg #f) cnt))
     (finish rg))
    ((primcall closure-set! ,var ,cnt ,res)
     (define reg (let ((res (emit res env fun rg #f)))
		   (if (eqv? res rg)
		       res
		       res)))
     (push-instr! fun (list 'CLOSURE-SET reg (emit var env fun rg #f) cnt))
     (finish rg))
    ((primcall ,op ,cell ,val ,loc)
     (guard (memq op '(STORE STORE_CHAR)))
     (let* ((val-cell (emit cell env fun rg #f))
	    (val-reg (emit val env fun (+ 1 rg) #f))
	    (val-loc (emit loc env fun (+ 2 rg) #f)))
       (push-instr! fun (list op val-cell val-reg val-loc))
       (finish rg)))
    ((primcall FOREIGN_CALL ,args ___)
     (let ((pos
	    (map-in-order
	     (lambda (sexp rg) (emit sexp env fun rg #f))
	     args (iota (length args) rg))))
       (for-each (lambda (res pos)
		   (unless (check-need-arg res pos)
		     (push-instr! fun (list 'ARG pos res))))
		 pos (iota (length args) rg))
       (push-instr! fun (list 'FCALL rg (length args)))
       (finish rg)))
    ;; Check for 'quick branches', which are always compiled to branches:
    ;; If it is not already in branch position, then it is compiled to
    ;; a branch with a true/false const.
    ((if (primcall ,op ,a ,b) ,true ,false)
     (guard (memq op quick-branches))
     (let* ((a-res (emit a env fun rg #f))
	    (b-res (emit b env fun (+ rg 1) #f))
	    (instr `(,(string->symbol (string-append "J" (symbol->string op))) ,rg ,a-res ,b-res))
	    (jinstr `(JMP 0 0))
	    (pos (+ 1 (length (fun-code fun)))))
       (push-instr! fun instr)
       (push-instr! fun jinstr)
       (let* ((reg-true (emit true env fun rg tail))
	      (unused (unless (or tail (not reg-true))
			(push-instr! fun (list 'ARG rg reg-true))))
	      (jmp (list 'JMP 0 0))
	      (jmp-pos (length (fun-code fun))))
	 (unless (or tail (not reg-true))
	   (push-instr! fun jmp))
	 (list-set! jinstr 2 (- (length (fun-code fun)) pos))
	 (let ((reg-false (emit false env fun rg tail)))
	   (unless (or tail (not reg-false))
	     (push-instr! fun (list 'ARG rg reg-false)))
	   (list-set! jmp 2 (- (length (fun-code fun)) jmp-pos))
	   (cond
	    (tail #f)
	    ((not (or reg-true reg-false)) #f)
	    (else rg))))))
    ((primcall ,op ,a ,b)
     (guard (memq op quick-branches))
     (emit `(if ,sexp #t #f) env fun rg tail))
    ((primcall ,var ,vals ___)
     ;; TODO: if we have re-used a reg, don't advance rg.
     (define regs (let loop ((vals vals) (rg rg) (res '()))
		    (if (not (pair? vals))
			(reverse! res)
			(let ((r (emit (car vals) env fun rg #f)))
			  (if (eqv? r rg)
			      (loop (cdr vals) (+ rg 1) (cons r res))
			      (loop (cdr vals) rg (cons r res)))))))
     (push-instr! fun `(,var ,rg ,@regs))
     (finish rg))
    ((if ,a ,b ,c)
     (define test (emit a env fun rg #f))
     (let ((instr `(IF ,test 0))
	   (pos (length (fun-code fun))))
       (push-instr! fun instr)
       (let* ((reg-true (emit b env fun rg tail))
	      (unused (unless (or tail (not reg-true))
			(push-instr! fun (list 'ARG rg reg-true))))
	      (jmp (list 'JMP 0 0))
	      (jmp-pos (length (fun-code fun))))
	 (unless (or tail (not reg-true))
	   (push-instr! fun jmp))
	 (list-set! instr 2 (- (length (fun-code fun)) pos))
	 (let ((reg-false (emit c env fun rg tail)))
	   (unless (or tail (not reg-false))
	     (push-instr! fun (list 'ARG rg reg-false)))
	   (list-set! jmp 2 (- (length (fun-code fun)) jmp-pos))
	   (cond
	    (tail #f)
	    ((not (or reg-true reg-false)) #f)
	    (else rg))))))
    ((call ,loop-var ,args ___)
     (guard (and (assq loop-var env) (loop-var? (cdr (assq loop-var env)))))
     (let ((lv (cdr (assq loop-var env)))
	   (pos
	    (map-in-order
	     (lambda (sexp rg) (emit sexp env fun rg #f))
	     args (iota (length args) rg))))
       (for-each (lambda (res pos)
		   (unless (check-need-arg res pos)
		     (push-instr! fun (list 'ARG pos res))))
		 pos (iota (length args) rg))
       (push-instr! fun (list 'LJMP rg
			      (- (length (fun-code fun)) (loop-var-dest lv)))))
     #f)
    ((call ,args ___)
     (let* ((pos
	    (map-in-order
	     (lambda (sexp rg) (emit sexp env fun rg #f))
	     args (iota (length args) (+ 1 rg)))))
       (for-each (lambda (res pos)
		   (unless (check-need-arg res pos)
		     (push-instr! fun (list 'ARG pos res))))
		 pos (iota (length args) (+ 1 rg))))
     (push-instr! fun (list 'CLOSURE_GET rg (+ 1 rg) (emit -1 env fun rg #f)))
     (push-instr! fun (list (if tail 'LCALLT 'LCALL) rg (+ 1 (length args))))
     (if tail #f rg))
    ((label-call ,label ,args ___)
     (let ((pos
	    (map-in-order
	     (lambda (sexp rg) (emit sexp env fun rg #f))
	     args (iota (length args) (+ 1 rg)))))
       (for-each (lambda (res pos)
		   (unless (check-need-arg res pos)
		     (push-instr! fun (list 'ARG pos res))))
		 pos (iota (length args) (+ rg 1))))
     (push-instr! fun (list 'CONST rg (add-constant fun `($label . ,(cdr (assq label env))))))
     (push-instr! fun (list (if tail 'LCALLT 'LCALL) rg (+ 1 (length args))))
     (if tail #f rg))
    ((let ((,vars ,vals) ___) ,body)
     (let ((pos
	    (map-in-order
	     (lambda (sexp rg) (emit sexp env fun rg #f))
	     vals (iota (length vals) rg))))
       (for-each (lambda (res pos)
		   (unless (check-need-arg res pos)
		     (push-instr! fun (list 'ARG pos res))))
		 pos (iota (length vals) rg))
       (let ((res (emit body (append (map cons vars (iota (length vals) rg)) env) fun (+ rg (length vals)) tail)))
	 (if res
	     (begin
	       (unless  (check-need-arg res rg)
		 (push-instr! fun (list 'ARG rg res)))
	       rg)
	     #f))))
    ((closure (label ,label) ,args ___)
     (let ((pos
	    (map-in-order
	     (lambda (sexp rg) (emit sexp env fun rg #f))
	     args (iota (length args) (+ 1 rg)))))
       (for-each (lambda (res pos)
		   (unless (check-need-arg res pos)
		     (push-instr! fun (list 'ARG pos res))))
		 pos (iota (length args) (+ rg 1))))
     (push-instr! fun (list 'CONST rg (add-constant fun `($label . ,(cdr (assq label env))))))
     (push-instr! fun (list 'CLOSURE rg (+ 1 (length args))))
     rg)
    ((const-closure (label ,label))
     (push-instr! fun (list 'CONST rg (add-constant fun `($const-closure . ,(cdr (assq label env))))))
     rg)
    ((labels ((,vars ,lambdas) ___) ,body)
     (let* ((label-ids (iota (length vars) (length functions)))
	    (funs (map-in-order (lambda (id) (define fun (make-fun 1))
					(push! functions fun)
					fun) label-ids))
	    (env (append (map cons vars label-ids) env)))
       (for-each (lambda (func-p nlambda var id)
		   (define name (second nlambda))
		   (define cases (cddr nlambda))
		   (define last-case (last cases))
		   (define last-case-jmp #f)
		   (fun-name-set! func-p name)
		   (for case cases
			(define argcnt (length (to-proper (second case))))
			(define v-type (list? (second case)))
			(define last (eq? case last-case))
			(when last-case-jmp
			  (list-set! last-case-jmp 2
				     (- (length (fun-code func-p)) (list-ref last-case-jmp 2))))
			(push-instr! func-p (list (if v-type (if last 'FUNC 'CFUNC) (if last 'FUNCV 'CFUNCV)) argcnt))
			(unless last
			  (let ((jmp `(JMP 0 ,(length (fun-code func-p)))))
			    (set! last-case-jmp jmp)
			    (push-instr! func-p jmp)))
			(emit (third case)
			      (append (map cons (to-proper (second case)) (iota argcnt))
				      env)
			      func-p
			      argcnt
			      #t)))
		 funs lambdas vars label-ids)
       (let ((res (emit body (append  env) fun rg tail)))
	 (if res
	     (begin
	       (unless (check-need-arg res rg)
		 (push-instr! fun (list 'ARG rg res)))
	       rg)
	     #f))))
    (,var
     (guard (symbol? var))
     (finish
      (cond
       ((assq var env) => cdr)
       (else
	(error "Unknown sym:" var)))))
    ((loop  ,vars ,name ,body ,inits ___)
     (define regs (iota (length inits) rg))
     (let ((pos
	    (map-in-order
	     (lambda (sexp rg) (emit sexp env fun rg #f))
	     inits regs)))
       (for-each (lambda (res pos)
		   (unless (check-need-arg res pos)
		     (push-instr! fun (list 'ARG pos res))))
		 pos regs))
     (let ((header (length (fun-code fun))))
       (push-instr! fun `(LOOP ,rg ,(length regs)))
       (let ((res (emit body (alist-cons name (make-loop-var header rg)
					 (append (map cons vars regs) env))
			fun (+ rg (length inits)) tail)))
	 (when (and (not tail) res)
	   (unless (check-need-arg res rg)
	     (push-instr! fun (list 'ARG rg res))))
	 (if (and (not tail) res)
	     rg
	     #f))))
    ((lookup ,var)
     (push-instr! fun (list 'LOOKUP rg (add-constant fun var)))
     (finish rg))
    (,const
     (guard (not (pair? const)))
     (push-instr! fun (list 'CONST rg (add-constant fun const)))
     (finish rg))
    ((quote ,const)
     (push-instr! fun (list 'CONST rg (add-constant fun const)))
     (finish rg))
    ((kill ,kills)
     (for kill kills
	  (push-instr! fun (list 'KILL (cdr (assq kill env))))))
    (,else (error "UNKOWN EMIT:" sexp))))

(define (dformat . args)
  (display (apply format args)))

(define (display-bc bc)
  (define jmp-dst '())
  (dformat "~a:\n" (fun-name bc))
  (display "Consts:\n")
  (fold (lambda (a b)
	      (dformat "~a: ~s\n" b a)
	      (+ b 1))
	0 (fun-const-list bc))
  (newline)
  (display "Code:\n")
  (fold (lambda (a b)
	  (define (str-op op)
	    (define ops (symbol->string op))
	    (string-append ops (make-string (- 15 (string-length ops)) #\space)))
	  (dformat "~a: ~a\t~a~a" b (if (or (eq? (first a) 'LOOP) (memq b jmp-dst)) "==>" "")
		   (str-op (first a)) (second a))
	  (if (> (length a) 2) (dformat "\t~a" (third a)))
	  (if (> (length a) 3) (dformat "\t~a" (fourth a)))
	  (let ((op (first a)))
	    (when (memq op '(DEFINE LOOKUP CONST))
	      (match (list-ref (fun-const-list bc) (third a))
		(($label . ,val)
		 (dformat "\t ;; LABEL ~a: ~a" val (fun-name (list-ref functions val))))
		(,const
		 (dformat  "\t ;; ~a" const))))
	    (when (memq op '(IF JMP))
	      (push! jmp-dst (+ b (third a)))
	      (dformat "\t ==> ~a" (+ b (third a))))
	    (when (eq? op 'LJMP)
	      (dformat "\t ==> ~a" (- b (third a)))))
	  
	  (newline)
	  (+ b 1))
	0 (fun-code bc))
  (newline))

(define (flonum? c)
  (and (number? c) (inexact? c)))

(define (fixnum? c)
  (and (number? c) (exact? c)
       (< (abs c) #x1fffffffffffffff)))

(define symbol-table (make-hash-table eq?))
(define symbol-table-pos 0)
(define (bc-write-const pos c p)
  (define (advance x) (set-car! pos (+ x (car pos))))
  (define (align)
    (unless (= 0 (modulo (car pos) 8))
      (advance 1)
      (write-u8 0 p)
      (align)))
  (define start-pos (car pos))
  (cond
   ((symbol? c)
    (cond
     ((hash-table-ref/default symbol-table c #f))
     (else
      (let* ((name-pos (bc-write-const pos (symbol->string c) p))
	     (sym-pos (car pos)))
	(write-u32 symbol-tag p) (advance 4)
	(write-u32 0 p) (advance 4)
	(write-u64 name-pos p) (advance 8)
	(if (eq? c 'symbol-table)
	    (write-u64 symbol-table-pos p)
	    (write-u64 undefined-tag p))
	(advance 8)
	(write-u64 0 p) (advance 8)
	(write-u64 0 p) (advance 8)
	(let ((res (+ sym-pos symbol-tag)))
	  (hash-table-set! symbol-table c res)
	  res)))))
   ((flonum? c)
    (write-u32 flonum-tag p) (advance 4)
    (write-u32 0 p) (advance 4)
    (write-double c p) (advance 8)
    (+ flonum-tag start-pos))
   ((fixnum? c)
    (* 8 c))
   ((char? c) (+ char-tag (* 256 (char->integer c))))
   ((boolean? c)
    (if c true-rep false-rep))
   ((null? c) nil-tag)
   ((string? c)
    (write-u32 string-tag p) (advance 4)
    (write-u32 0 p) (advance 4)
    ;; Null-terminate
    (write-u64 (* 8 (string-length c)) p) (advance 8)
    (for-each (lambda (c) (write-u8 (char->integer c) p)) (string->list c))
    (write-u8 0 p)
    (advance (+ 1 (string-length c)))
    (align)
    (+ ptr-tag start-pos))
   ((and (pair? c) (eq? '$label (car c)))
    (let ((fun (list-ref functions (cdr c))))
      (fun-bc-start fun)))
   ;; TODO use a record
   ((and (pair? c) (eq? '$const-closure (car c)))
    (write-u32 closure-tag p) (advance 4)
    (write-u32 0 p) (advance 4)
    (write-u64 (* 8 1) p) (advance 8)
    (write-u64 (fun-bc-start (list-ref functions (cdr c))) p) (advance 8)
    (+ closure-tag start-pos))
   ((vector? c)
    (let* ((vals (vector-map (lambda (c) (bc-write-const pos c p)) c))
	   (vec-pos (car pos)))
      (write-u32 vector-tag p) (advance 4)
      (write-u32 0 p) (advance 4)
      (write-u64 (* 8 (vector-length c)) p) (advance 8)
      (vector-map (lambda (val)
		    (write-u64 val p) (advance 8))
		  vals)
      (+ vector-tag vec-pos)))
   ((pair? c)
    (let* ((pa (bc-write-const pos (car c) p))
	   (pb (bc-write-const pos (cdr c) p))
	   (pair-pos (car pos)))
      (write-u32 cons-tag p) (advance 4)
      (write-u32 0 p) (advance 4)
      (write-u64 pa p) (advance 8)
      (write-u64 pb p) (advance 8)
      (+ pair-pos cons-tag)))
   (else (dformat "Can't serialize: ~a\n" c)
	 0
	 ;(0)
	 )))

(define (bc-serialize program)
  (define p (open-output-bytevector))
  (define pos (cons 0 #f))
  (define (align)
    (unless (= 0 (modulo (car pos) 8))
      (advance 1)
      (write-u8 0 p)
      (align)))
  (define (advance x) (set-car! pos (+ x (car pos))))
  (define last-fun 0)
  (set! symbol-table (make-hash-table eq?))
  (for bc program
       (define consts (omap const (fun-const-list bc)
			    (bc-write-const pos const p)))
       (define name (bc-write-const pos (fun-name bc) p))
       (set! last-fun (car pos))
       (fun-bc-start-set! bc (+ last-fun ptr-tag))
       
       (write-u32 func-tag p) (advance 4)
       (write-u32 0 p) (advance 4)
       (write-u64 name p) (advance 8)
       (write-u64 0 p) (advance 8) ;; jitted ptr
       (write-u64 0 p) (advance 8) ;; jitrun ptr
       ;; TODO fixnum?
       (write-u64 (hash-table-size (fun-const bc)) p) (advance 8)
       (write-u64 (length (fun-code bc)) p) (advance 8)
       (for const consts
	    (write-u64 const p)
	    (advance 8))

       ;; Write bitcode
       (let ((bc-start (car pos)))
	 (for c (fun-code bc)
	      (define ins (assq (first c) opcodes))
	      (when (not ins)
		(dformat "ERROR could not find ins ~a\n" c)
		(exit -1))
	      (write-u8 (second ins) p)
	      (write-u8 (if (> (length c) 1) (second c) 0) p)
	      (if (memq (first c) bc-ins)
		  (if (memq (first c) '(CONST DEFINE LOOKUP))
		      (let ((offset (+ (/ (- (car pos) bc-start) 4)
				       (* 2 (- (hash-table-size (fun-const bc)) (third c))))))
			(unless (< 0 offset 65536) (error "Bad const offset"))
			(write-u16 offset p))
		      (if (>= (length c) 3)
			  (write-u16 (third c) p)
			  (write-u16 0 p)))
		  (begin
		    (write-u8 (if (> (length c) 2) (third c) 0) p)
		    (write-u8 (if (> (length c) 3) (fourth c) 0) p)))
	      (advance 4))
	 (align)))
  ;; serialize the symbol table, so string->symbol works for compiled symbols
  (set! symbol-table-pos 
	(bc-write-const pos
			(omap key (hash-table-keys symbol-table)
			      (cons (symbol->string key) key))
			p))
  (values (get-output-bytevector p) last-fun))

(define (bc-write name program)
  (define p (open-binary-output-file name))
  ;; We serialize *twice*: Once to get position offsets in the file,
  (define-values (unused-image unused-start) (bc-serialize program))
  ;; And a second time to emit, knowing forward reference offsets.
  (define-values (image start) (bc-serialize program))
  ;; Magic
  (write-u8 (char->integer #\F) p)
  (write-u8 (char->integer #\L) p)
  (write-u8 (char->integer #\O) p)
  (write-u8 (char->integer #\W) p)
  ;; version
  (write-u64 0 p)
  ;; Length
  (write-u64 (bytevector-length image) p)
  ;; Start function
  (write-u64 start p)
  ;; Image.
  (write-bytevector image p)
  (close-output-port p))

(define (compile file verbose)
  (set! functions '())
  (let* ((libman (make-libman))
	 (runtime-input (with-input-from-file "runtime.scm" read-file))
	 (pre-input (with-input-from-file file read-file))
	 ;; Auto-add 'import' to scripts.
	 (input
	  (match pre-input
	    (((import ,anything ___) ,body ___) pre-input)
	    (,else `((import (scheme base) (scheme r5rs) (scheme time) (scheme file)) ,@pre-input))))
	 (unused (expander-init libman))
	 (runtime (expand-program runtime-input "" libman))
	 (prog (expand-program input "PROG-" libman))
	 (lowered (r7-pass `(begin ,@runtime      ,@prog
			      ) #f))
	 (main-fun (make-fun "main")))
    (when verbose
      (display (format "Compiling ~a\n" file) (current-error-port))
      (pretty-print lowered))

    (emit lowered '() main-fun 0 #t)
    
    (set! functions (reverse! (cons main-fun functions)))
    (for func functions
	 (fun-const-list-set! func (reverse! (fun-const-list func)))
	 (fun-code-set! func (reverse! (fun-code func))))
    
    (when verbose
      (fold (lambda (a b)
	      (dformat "~a -- " b)
	      (display-bc a)
	      (+ b 1))
	    0
	    functions))
    (bc-write (string-append file ".bc") functions)))

(for file (cdr (command-line))
     (compile file #t))

