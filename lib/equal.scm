;; Efficient Nondestructive Equality Checking for Trees and Graph
;; Michael D. Adams and R. Kent Dybvig
(define (pre? x y k)
  (cond
   ((eq? x y) k)
   ((pair? x)
    (and (pair? y)
	 (if (<= k 0)
	     k
	     (let ((k (pre? (car x) (car y) (- k 1))))
	       (and k (pre? (cdr x) (cdr y) k))))))
   ((vector? x)
    (and (vector? y)
	 (let ((n (vector-length x)))
	   (and (= (vector-length y) n)
		(let f ((i 0) (k k))
		  (if (or (= i n) (<= k 0))
		      k
		      (let ((k (pre? (vector-ref x i)
				     (vector-ref y i)
				     (- k 1))))
			(and k (f (+ i 1) k)))))))))
   ((string? x) (and (string? y) (string=? x y) k))
   ((bytevector? x) (and (bytevector? y) (bytevector=? x y) k))
   (else (and (eqv? x y) k))))

(define k0 400)
(define kb -40)
(define (random x) x)
(define (interleave? x y k)
  (let ((ht #f))
    (define (call-union-find x y)
      (unless ht (set! ht (make-hash-table)))
      (union-find ht x y))
    (define (e? x y k)
      (if (<= k 0)
	  (if (= k kb)
	      (fast? x y (random (* 2 k0)))
	      (slow? x y k))
	  (fast? x y k)))
    (define (slow? x y k)
      (cond
       ((eq? x y) k)
       ((pair? x)
	(and (pair? y)
	     (if (call-union-find x y)
		 0
		 (let ((k (e? (car x) (car y) (- k 1))))
		   (and k (e? (cdr x) (cdr y) k))))))
       ((vector? x)
	(and (vector? y)
	     (let ((n (vector-length x)))
	       (and (= (vector-length y) n)
		    (if (call-union-find x y)
			0
			(let f ((i 0) (k (- k 1)))
			  (if (= i n)
			      k
			      (let ((k (e? (vector-ref x i)
					   (vector-ref y i) k)))
				(and k (f (+ i 1) k))))))))))
       ((string? x) (and (string? y) (string=? x y) k))
       ((bytevector? x) (and (bytevector? y) (bytevector=? x y) k))
       (else (and (eqv? x y) k))))
    (define (fast? x y k)
      (let ((k (- k 1)))
	(cond
	 ((eq? x y) k)
	 ((pair? x)
	  (and (pair? y)
	       (let ((k (e? (car x) (car y) k)))
		 (and k (e? (cdr x) (cdr y) k)))))
	 ((vector? x)
	  (and (vector? y)
	       (let ((n (vector-length x)))
		 (and (= (vector-length y) n)
		      (let f ((i 0) (k k))
			(if (= i n)
			    k
			    (let ((k (e? (vector-ref x i)
					 (vector-ref y i) k)))
			      (and k (f (+ i 1) k)))))))))
	 ((string? x) (and (string? y) (string=? x y) k))
	 ((bytevector? x) (and (bytevector? y) (bytevector=? x y) k))
	 (else (and (eqv? x y) k)))))
    (and (e? x y k) #t)))

(define (equal? x y)
  (let ((k (pre? x y k0)))
    (and k (or (> k 0) (interleave? x y k)))))

(define-record-type box-type (box val) box?
		    (val unbox set-box!))
(define (union-find ht x y)
  (define (find b)
    (let ((n (unbox b)))
      (if (box? n)
	  (let loop ((b b) (n n))
	    (let ((nn (unbox n)))
	      (if (box? nn)
		  (begin
		    (set-box! b nn)
		    (loop n nn))
		  n)))
	  b)))
  (let ((bx (hash-table-ref/default ht x #f))
	(by (hash-table-ref/default ht y #f)))
    (if (not bx)
	(if (not by)
	    (let ((b (box 1)))
	      (hash-table-set! ht x b)
	      (hash-table-set! ht y b)
	      #f)
	    (let ((ry (find by)))
	      (hash-table-set! ht x ry)
	      #f))
	(if (not by)
	    (let ((rx (find bx)))
	      (hash-table-set! ht y rx)
	      #f)
	    (let ((rx (find bx)) (ry (find by)))
	      (or (eq? rx ry)
		  (let ((nx (unbox rx))
			(ny (unbox ry)))
		    (if (> nx ny)
			(begin
			  (set-box! ry rx)
			  (set-box! rx (+ nx ny))
			  #f)
			(begin
			  (set-box! rx ry)
			  (set-box! ry (+ ny nx))
			  #f)))))))))
