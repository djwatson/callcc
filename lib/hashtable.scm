;; Simple EQ hash tables, open addressing, linear probing.

(define-record-type hash-table (%make-hash-table hash cmp size maxsize entries) hash-table?
		    (hash hash-table-hash)
		    (cmp hash-table-cmp)
		    (size hash-table-size hash-table-size-set!)
		    (maxsize hash-table-maxsize hash-table-maxsize-set!)
		    (entries hash-table-entries hash-table-entries-set!))

(define make-hash-table
  (case-lambda
   (() (%make-hash-table eqhash eq? 0 1792 (make-vector 2048 #f)))
   ((hash cmp) (%make-hash-table hash cmp 0 1792 (make-vector 2048 #f)))))
(define (hash-modulo h len) (sys:FOREIGN_CALL "SCM_AND" h (- len 1)))
(define (hash-table-ref/default ht key default)
  (let* ((size (hash-table-size ht))
	 (table (hash-table-entries ht))
	 (len (vector-length table))
	 (hash (hash-table-hash ht))
	 (cmp (hash-table-cmp ht))
	 (idx (hash-modulo (hash key) len)))
    (let loop ((idx idx))
      (let ((cur (vector-ref table idx)))
	(cond
	 ((not cur) default)
	 ((cmp (car cur) key) (cdr cur))
	 (else (loop (hash-modulo (+ idx 1) len))))))))
(define (hash-table-grow ht)
  (let ((old-entries (hash-table-entries ht)))
    (hash-table-entries-set! ht (make-vector (* (vector-length old-entries) 2) #f))
    (hash-table-maxsize-set! ht (* 2 (hash-table-maxsize ht)))
    (do ((idx 0 (+ idx 1)))
	((= idx (vector-length old-entries)))
      (let ((cur (vector-ref old-entries idx)))
	(when cur
	  (hash-table-set-pair! ht cur))))))
(define (eqhash x) (sys:FOREIGN_CALL "SCM_EQ_HASH" x))
(define (string-hash x) (sys:FOREIGN_CALL "SCM_STRING_HASH" x))
(define (hash-table-set! ht key value)
  (hash-table-set-pair! ht (cons key value)))
(define (hash-table-set-pair! ht kv)
  (let* ((size (hash-table-size ht))
	 (entries (hash-table-entries ht))
	 (len (vector-length entries)))
    (when (= (+ size 1) (hash-table-maxsize ht))
      (hash-table-grow ht)))
  (let* ((size (hash-table-size ht))
	 (table (hash-table-entries ht))
	 (len (vector-length table))
	 (hash (hash-table-hash ht))
	 (cmp (hash-table-cmp ht))
	 (idx (hash-modulo (hash (car kv)) len)))
    (let loop ((idx idx))
      (let ((cur (vector-ref table idx)))
	(cond
	 ((not cur)
	  (vector-set! table idx kv)
	  (hash-table-size-set! ht (+ 1 (hash-table-size ht))))
	 ((cmp (car cur) (car kv)) (vector-set! table idx kv))
	 (else (loop (hash-modulo (+ idx 1) len))))))))


;; (define ht (make-hash-table 'unused))
;; (hash-table-set! ht 4 4)
;; (display (hash-table-ref/default ht 11 #f))
;; (display (hash-table-ref/default ht 4 #f))
;; (hash-table-set! ht 8 8)
;; (display (hash-table-ref/default ht 11 #f))
;; (display (hash-table-ref/default ht 4 #f))
;; (display (hash-table-ref/default ht 8 #f))
;; (display (hash-table-ref/default ht 9 #f))
;; (hash-table-set! ht 9 9)
;; (hash-table-set! ht 16 16)
;; (display (hash-table-ref/default ht 11 #f))
;; (display (hash-table-ref/default ht 4 #f))
;; (display (hash-table-ref/default ht 8 #f))
;; (display (hash-table-ref/default ht 9 #f))
;; (display (hash-table-ref/default ht 16 #f))
;; (display (hash-table-ref/default ht 17 #f))
